<!DOCTYPE html>
<html>

<head>
    <title>Hydration MVP</title>
    <style>
        body {
            font-family: monospace;
            background: #222;
            color: #0f0;
            padding: 20px;
        }
    </style>
</head>

<body>
    <h2>Hydration Status:</h2>
    <div id="logs"></div>

    <script>
        const logsEl = document.getElementById('logs');
        function log(msg, data) {
            logsEl.innerHTML += "<p style='margin: 4px 0'>[" + msg + "] " + (data ? JSON.stringify(data) : '') + "</p>";
        }

        // Emulate React component state
        let componentState = {
            budget: null,
            occasion: null,
            recipient_address: null,
            api_base_url: null
        };

        function updateStateDisplay() {
            let displayEl = document.getElementById('state-display');
            if (!displayEl) {
                displayEl = document.createElement('div');
                displayEl.id = 'state-display';
                displayEl.style.cssText = "position: fixed; top: 20px; right: 20px; background: #000; border: 1px solid #0f0; padding: 10px;";
                document.body.appendChild(displayEl);
            }
            displayEl.innerHTML = "<h3>React Component State:</h3><pre>" + JSON.stringify(componentState, null, 2) + "</pre>";
        }

        // Emulate React's hydration useEffect setter
        function hydrateComponentWithData(data) {
            if (!data || typeof data !== 'object') return;
            let updated = false;

            if (data.budget !== undefined && data.budget !== null) {
                componentState.budget = data.budget;
                updated = true;
            }
            if (data.occasion !== undefined && data.occasion !== null) {
                componentState.occasion = data.occasion;
                updated = true;
            }
            if (data.recipient_address !== undefined && data.recipient_address !== null) {
                componentState.recipient_address = data.recipient_address;
                updated = true;
            }
            if (data.api_base_url !== undefined && data.api_base_url !== null) {
                componentState.api_base_url = data.api_base_url;
                updated = true;
            }

            if (updated) {
                log("COMPONENT STATE UPDATED!", componentState);
                updateStateDisplay();
            }
        }

        function extractHydrationData(source) {
            if (!source) return null;
            const candidates = [
                source.toolOutput,
                source.structuredContent,
                source.result?.structuredContent,
                source.toolInput
            ];
            for (const c of candidates) {
                if (c && typeof c === 'object' && Object.keys(c).length > 0) {
                    return c;
                }
            }
            return null;
        }

        // 1. Initial State Check (Mount)
        updateStateDisplay();
        if (typeof window !== 'undefined' && window.openai) {
            log("INIT window.openai exists");
            const data = extractHydrationData(window.openai);
            if (data) {
                log("INIT Hydrating from window.openai", data);
                hydrateComponentWithData(data);
            }
        }

        // 2. Legacy Pattern Event Listener (Rapid sequential fires)
        window.addEventListener('openai:set_globals', (ev) => {
            const globals = ev?.detail?.globals;
            if (globals) {
                log("EVENT openai:set_globals FIRING");
                const data = extractHydrationData(globals);
                if (data) {
                    hydrateComponentWithData(data);
                }
            }
        });

        // 3. Official Apps SDK JSON-RPC Pattern
        let rpcId = 0;
        const pendingReqs = new Map();

        function rpcNotify(method, params) {
            window.parent.postMessage({ jsonrpc: "2.0", method, params }, "*");
        }

        function rpcRequest(method, params) {
            return new Promise((resolve, reject) => {
                const id = ++rpcId;
                pendingReqs.set(id, { resolve, reject });
                window.parent.postMessage({ jsonrpc: "2.0", id, method, params }, "*");
            });
        }

        window.addEventListener("message", (event) => {
            if (event.source !== window.parent) return;
            const message = event.data;
            if (!message || message.jsonrpc !== "2.0") return;

            if (typeof message.id === "number") {
                const pending = pendingReqs.get(message.id);
                if (!pending) return;
                pendingReqs.delete(message.id);
                if (message.error) pending.reject(message.error);
                else pending.resolve(message.result);
                return;
            }

            if (message.method === "ui/notifications/tool-result") {
                log("RPC TOOL RESULT FIRING");
                const toolResult = message.params;
                const data = toolResult?.structuredContent || toolResult?.result?.structuredContent;
                if (data) {
                    hydrateComponentWithData(data);
                }
            }
        });

        // SDK Handshake
        async function handshake() {
            try {
                await rpcRequest("ui/initialize", {
                    appInfo: { name: "hydration_test", version: "1.0.0" },
                    appCapabilities: {},
                    protocolVersion: "2026-01-26"
                });
                rpcNotify("ui/notifications/initialized", {});
            } catch (err) { }
        }

        // Uncomment below to test if JSON-RPC bridge conflict reproduces easily
        // setTimeout(handshake, 500);
    </script>
</body>

</html>